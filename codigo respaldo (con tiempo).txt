import tkinter as tk
import os
import json

# Funci√≥n para cargar preguntas desde el archivo JSON
def load_questions():
    if not os.path.exists("preguntas.json"):
        return None  # Retorna None si no hay archivo

    with open("preguntas.json", "r", encoding="utf-8") as file:
        return json.load(file)

# Cargar preguntas desde el archivo externo
questions_data = load_questions()

# Obtener niveles din√°micamente seg√∫n el JSON
all_levels = []
if questions_data:
    for key in sorted(questions_data.keys()):  # Ordenar niveles por nombre (level_1, level_2, ...)
        all_levels.append(questions_data[key])

# Variables globales
current_question = 0
score = 0
time_left = 10
timer_id = None
level = 0
error_window = None  
questions = all_levels[level] if all_levels else []

# Variable global para la ventana de puntuaciones
scores_window = None 

# Colores y estilos
BACKGROUND_COLOR = "#1E1E2E"  # Azul oscuro
BUTTON_COLOR = "#FF9800"  # Naranja vibrante
BUTTON_HOVER = "#FFC107"  # Amarillo cuando el cursor est√° encima
TEXT_COLOR = "#FFFFFF"  # Blanco
QUESTION_BOX_COLOR = "#252547"  # Color de fondo del cuadro de pregunta
TIMER_COLOR = "#FF4444"  # Barra de tiempo

# Funci√≥n para iniciar el juego
def start_game():
    global current_question, score, time_left, level, questions

    if not all_levels:
        show_no_questions_message()
        return

    current_question = 0
    score = 0  
    time_left = 10
    level = 0
    questions = all_levels[level]

    update_score_label()
    main_frame.pack_forget()
    question_frame.pack(fill="both", expand=True)

    load_question()

# Funci√≥n para verificar respuesta
def check_answer(selected_option):
    global current_question, score, level, questions, timer_id

    if selected_option == questions[current_question]["answer"]:
        score += 1

    current_question += 1
    root.after_cancel(timer_id)

    if current_question < len(questions):
        load_question()
    else:
        if score == sum(len(lvl) for lvl in all_levels[:level + 1]):
            if level < len(all_levels) - 1:
                level += 1
                show_level_up_message()
            else:
                show_results("¬°Felicidades! Completaste todos los niveles")
        else:
            show_results("Puntos insuficientes para avanzar")

# Funci√≥n para mostrar mensaje de "Has avanzado al Nivel 2" por 2 segundos
def show_level_up_message():
    question_frame.pack_forget()
    level_up_label.config(text=f"¬°Has avanzado al Nivel {level + 1}!")
    level_up_frame.pack(fill="both", expand=True)
    root.after(2000, continue_to_next_level)

# Funci√≥n para cargar el Nivel 2 despu√©s del mensaje
def continue_to_next_level():
    global current_question, questions

    level_up_frame.pack_forget()
    question_frame.pack(fill="both", expand=True)

    current_question = 0
    questions = all_levels[level]
    load_question()

# Funci√≥n para cargar una nueva pregunta
def load_question():
    global time_left, timer_id
    
    question_data = questions[current_question]
    question_label.config(text=question_data["question"])
    
    for i, option in enumerate(question_data["options"]):
        buttons[i].config(text=option, command=lambda opt=option: check_answer(opt))
    
    time_left = 10
    timer_label.config(text=f"Tiempo restante: {time_left} s")
    update_score_label()
    
    if timer_id is not None:
        root.after_cancel(timer_id)
    countdown()

# Funci√≥n del temporizador
def countdown():
    global time_left, timer_id

    if time_left > 0:
        time_left -= 1
        timer_label.config(text=f"Tiempo restante: {time_left} s")

        # Ajustar el ancho del rect√°ngulo en el Canvas
        timer_bar.coords(timer_rect, 0, 0, int((time_left / 10) * 200), 10)  # Cambiar dimensiones del rect√°ngulo

        timer_id = root.after(1000, countdown)  # Llama a countdown despu√©s de 1 segundo
    else:
        show_results("¬°Se acab√≥ el tiempo!")

# Funci√≥n para mostrar los resultados con el puntaje
def show_results(message):
    global timer_id, score

    if timer_id:
        root.after_cancel(timer_id)

    results_label.config(text=f"{message}\n\nPuntaje obtenido: {score}")
    name_entry.delete(0, tk.END)  
    
    question_frame.pack_forget()
    results_frame.pack(fill="both", expand=True)

# Funci√≥n para guardar el puntaje en un archivo
# N√∫mero m√°ximo de puntuaciones a almacenar
MAX_SCORES = 7
# Funci√≥n para guardar el puntaje en un archivo usando una cola FIFO
def save_score():
    global score

    player_name = name_entry.get().strip()

    if len(player_name) > 5:
        player_name = player_name[:5]  # Limitar a 5 caracteres

    if not player_name:  # No guardar si no se introduce un nombre
        return

    scores = []

    # Leer el archivo y cargar las puntuaciones existentes
    if os.path.exists("puntajes.txt"):
        with open("puntajes.txt", "r") as file:
            scores = [line.strip() for line in file.readlines()]

    # Convertir la lista de puntuaciones en una lista de tuplas (nombre, puntaje)
    score_tuples = []
    for s in scores:
        try:
            name, points = s.rsplit(":", 1)
            points = int(points.strip())  # Convertir a n√∫mero
            score_tuples.append((name.strip(), points))
        except ValueError:
            continue  # Ignorar l√≠neas con formato incorrecto

    # Agregar la nueva puntuaci√≥n si cumple la condici√≥n
    if len(score_tuples) < MAX_SCORES or score > min(points for _, points in score_tuples):
        score_tuples.append((player_name, score))

    # Ordenar la lista de mayor a menor puntaje
    score_tuples.sort(key=lambda x: x[1], reverse=True)

    # Mantener solo los 7 mejores puntajes
    score_tuples = score_tuples[:MAX_SCORES]

    # Guardar la lista actualizada en el archivo
    with open("puntajes.txt", "w") as file:
        for name, points in score_tuples:
            file.write(f"{name}: {points}\n")

    return_to_main()  # Volver a la pantalla principal despu√©s de guardar

# Funci√≥n para volver a la pantalla principal
def return_to_main():
    global score

    score = 0  
    update_score_label()

    results_frame.pack_forget()
    main_frame.pack(fill="both", expand=True)

# Funci√≥n para actualizar el puntaje en pantalla
def update_score_label():
    score_label.config(text=f"Puntaje: {score}")

# Funci√≥n para mostrar el contenido de puntajes.txt
def show_scores():
    global scores_window  

    # Si la ventana ya est√° abierta, la trae al frente
    if scores_window and scores_window.winfo_exists():  
        scores_window.lift()  
        return  

    # Crear ventana emergente para puntuaciones
    scores_window = tk.Toplevel(root)
    scores_window.title("üìú Puntuaciones")
    scores_window.geometry("400x320")
    scores_window.configure(bg=BACKGROUND_COLOR)

    # T√≠tulo de la ventana
    title_label = tk.Label(scores_window, text="üèÜ Mejores Puntajes üèÜ", 
                           font=("Arial", 18, "bold"), fg="white", bg=BACKGROUND_COLOR)
    title_label.pack(pady=10)

    # Marco para las puntuaciones con scrollbar
    scores_frame = tk.Frame(scores_window, bg=QUESTION_BOX_COLOR, padx=10, pady=10)
    scores_frame.pack(pady=5, padx=10, fill="both", expand=True)

    scores_canvas = tk.Canvas(scores_frame, bg=QUESTION_BOX_COLOR, highlightthickness=0)
    scores_scrollbar = tk.Scrollbar(scores_frame, orient="vertical", command=scores_canvas.yview)
    scores_list_frame = tk.Frame(scores_canvas, bg=QUESTION_BOX_COLOR)

    scores_list_frame.bind("<Configure>", lambda e: scores_canvas.configure(scrollregion=scores_canvas.bbox("all")))

    scores_window_frame = scores_canvas.create_window((0, 0), window=scores_list_frame, anchor="nw")

    scores_canvas.configure(yscrollcommand=scores_scrollbar.set)

    scores_canvas.pack(side="left", fill="both", expand=True)
    scores_scrollbar.pack(side="right", fill="y")

    # Leer el archivo de puntuaciones
    try:
        with open("puntajes.txt", "r") as file:
            scores_content = file.readlines()
    except FileNotFoundError:
        scores_content = ["No hay puntuaciones registradas."]

    # Mostrar cada puntuaci√≥n con formato llamativo
    for idx, score in enumerate(scores_content):
        score_label = tk.Label(scores_list_frame, text=f"ü•á {score.strip()}",
                               font=("Arial", 14), fg="white", bg=QUESTION_BOX_COLOR, anchor="w", justify="left")
        score_label.pack(anchor="w", padx=10, pady=2)

    # Bot√≥n para cerrar la ventana
    close_button = tk.Button(scores_window, text="‚ùå Cerrar", font=("Arial", 12, "bold"), 
                             bg=BUTTON_COLOR, fg="black", activebackground=BUTTON_HOVER, command=scores_window.destroy)
    close_button.pack(pady=10)

# Crear ventana principal
root = tk.Tk()
root.title("Juego de Preguntas")
root.geometry("700x450")
root.configure(bg=BACKGROUND_COLOR)

# Funci√≥n para mostrar mensaje de error si no hay preguntas
def show_no_questions_message():
    global error_window
    if error_window and error_window.winfo_exists():  # Evita abrir m√∫ltiples ventanas
        return
    
    error_window = tk.Toplevel(root)
    error_window.title("Error")
    error_window.geometry("400x200")
    error_window.configure(bg="#1E1E2E")
    
    error_label = tk.Label(error_window, text="‚ö†Ô∏è No se encontraron preguntas ‚ö†Ô∏è", font=("Arial", 14, "bold"), fg="#FFD700", bg="#1E1E2E", wraplength=380)
    error_label.pack(pady=20)
    
    error_message = tk.Label(error_window, text="Aseg√∫rate de agregar un archivo preguntas.json para jugar.", font=("Arial", 12), fg="#FFFFFF", bg="#1E1E2E", wraplength=380)
    error_message.pack(pady=10)
    
    close_button = tk.Button(error_window, text="Aceptar", font=("Arial", 12, "bold"), bg="#FF9800", fg="black", activebackground="#FFC107", command=error_window.destroy)
    close_button.pack(pady=20)

# --------- Pantalla principal ---------
main_frame = tk.Frame(root, bg=BACKGROUND_COLOR)
main_frame.pack(fill="both", expand=True)  # Hace que el frame ocupe toda la ventana

# Frame interno para centrar elementos
content_frame = tk.Frame(main_frame, bg=BACKGROUND_COLOR)
content_frame.place(relx=0.5, rely=0.43, anchor="center")  # Centrar elementos

title_label = tk.Label(content_frame, text="üéÆ Juego de Preguntas üéÆ", font=("Arial", 20, "bold"), fg=TEXT_COLOR, bg=BACKGROUND_COLOR)
title_label.pack(pady=20)  # Espaciado entre elementos

# Funci√≥n para efectos de hover en botones
def on_hover(event):
    event.widget.config(bg=BUTTON_HOVER)

def on_leave(event):
    event.widget.config(bg=BUTTON_COLOR)

# Bot√≥n para jugar
play_button = tk.Button(content_frame, text="‚ñ∂ Jugar", font=("Arial", 14, "bold"), width=15, bg=BUTTON_COLOR, fg="black", activebackground=BUTTON_HOVER, command=start_game)
play_button.pack(pady=10)
play_button.bind("<Enter>", on_hover)
play_button.bind("<Leave>", on_leave)

# Bot√≥n para ver puntuaciones
scores_button = tk.Button(content_frame, text="üìú Puntuaciones", font=("Arial", 14, "bold"), width=15, bg=BUTTON_COLOR, fg="black", activebackground=BUTTON_HOVER, command=show_scores)
scores_button.pack(pady=10)
scores_button.bind("<Enter>", on_hover)
scores_button.bind("<Leave>", on_leave)

# --------- Pantalla de preguntas ---------
question_frame = tk.Frame(root, bg=BACKGROUND_COLOR)

score_label = tk.Label(question_frame, text="Puntaje: 0", font=("Arial", 14, "bold"), fg=TEXT_COLOR, bg=BACKGROUND_COLOR)
score_label.pack(pady=5)

# Cuadro de pregunta
question_box = tk.Frame(question_frame, bg=QUESTION_BOX_COLOR, padx=20, pady=20)
question_box.pack(pady=10, padx=20, fill="x")

question_label = tk.Label(question_box, text="", wraplength=400, font=("Arial", 14, "bold"), fg=TEXT_COLOR, bg=QUESTION_BOX_COLOR)
question_label.pack()

# Botones de respuesta
buttons = []
for _ in range(4):
    btn = tk.Button(question_frame, text="", width=40, font=("Arial", 12, "bold"), bg=BUTTON_COLOR, fg="black", relief="raised")
    btn.pack(pady=5)
    buttons.append(btn)

# Barra de tiempo (fondo neutro)
timer_label = tk.Label(question_frame, text="Tiempo restante: 10 s", font=("Arial", 12, "bold"), fg=TIMER_COLOR, bg=BACKGROUND_COLOR)
timer_label.pack(pady=5)

timer_bar = tk.Canvas(question_frame, height=10, width=200, bg=BACKGROUND_COLOR, highlightthickness=0)  # Color de fondo neutro
timer_bar.pack(pady=10)

# Inicializar la barra de tiempo
timer_rect = timer_bar.create_rectangle(0, 0, 200, 10, fill=TIMER_COLOR, outline="")

# --------- Pantalla de resultados ---------
results_frame = tk.Frame(root, bg=BACKGROUND_COLOR)

results_label = tk.Label(results_frame, text="", font=("Arial", 14), fg=TEXT_COLOR, bg=BACKGROUND_COLOR)
results_label.pack(pady=10)

name_entry = tk.Entry(results_frame, font=("Arial", 12), width=10)
name_entry.pack(pady=5)
name_entry.insert(0, "Nombre")

save_button = tk.Button(results_frame, text="üíæ Guardar y volver al men√∫", font=("Arial", 12, "bold"), bg=BUTTON_COLOR, fg="black", activebackground=BUTTON_HOVER, command=save_score)
save_button.pack(pady=10)
save_button.bind("<Enter>", on_hover)
save_button.bind("<Leave>", on_leave)

# --------- Pantalla de avance de nivel ---------
level_up_frame = tk.Frame(root, bg=BACKGROUND_COLOR)

level_up_label = tk.Label(level_up_frame, text="üéâ ¬°Has avanzado al Nivel 2! üéâ", 
                          font=("Arial", 20, "bold"), fg="#FFD700", bg=BACKGROUND_COLOR)
level_up_label.pack(pady=20)

level_up_message = tk.Label(level_up_frame, text="Prep√°rate para preguntas m√°s desafiantes. ¬°Buena suerte! üéØ",
                            font=("Arial", 14), fg=TEXT_COLOR, bg=BACKGROUND_COLOR, wraplength=500)
level_up_message.pack(pady=10)

# Icono visual atractivo (puede ser un GIF o un emoji grande)
level_up_icon = tk.Label(level_up_frame, text="üöÄ", font=("Arial", 50), fg="white", bg=BACKGROUND_COLOR)
level_up_icon.pack(pady=20)

# --------- Iniciar la aplicaci√≥n ---------
root.mainloop()
